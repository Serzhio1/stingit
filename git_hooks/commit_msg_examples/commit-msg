#!/usr/bin/env bash
set -euo pipefail
# ============================================================
#                   Git Commit Message Hook
# ------------------------------------------------------------
# Скрипт для проверки формата сообщения коммита
#
# Требования к сообщению коммита:
#  1. В начале обязательно один из типов:
#       fix:, refactor:, test:
#  2. Далее через пробел ссылка на задачу в JIRA в формате:
#       [OSG-123], [OSG-12], [OSG-1234] и т.п.
#  3. После этого через пробел должно идти содержательное сообщение,
#       не являющееся слишком общим/мусорным (например, "fix bug", "do smth" и т.п.)
#
# Примеры правильных сообщений:
#  - fix: [OSG-123] исправлен баг с авторизацией
#  - docs: [OSG-12] обновлена документация по API
#  - refactor: [OSG-134] переработан модуль логирования
#  - test: [OSG-56] добавлены тесты для нового функционала
#
# Примеры сообщений, которые вызовут ошибку:
#  - fix bug
#  - do smth
#  - test: [OSG-123]
#  - update [OSG-12] minor changes
#
# Важно:
#  - Этот скрипт выполняется на этапе "commit", после того как сообщение коммита сформировано
#  - Скрипт должен называться ровно: "commit-msg", и никак иначе
#  - Скрипт должен находиться в каталоге: ".git/hooks/", и нигде иначе
#  - Файл должен быть исполняемым (chmod +x)
#
# ============================================================


# Переменные, в которых не стоит менять значения
COMMIT_MESSAGE_FILE="$1"
ROW_COMMIT_MESSAGE=$(<"$COMMIT_MESSAGE_FILE")
COMMIT_MESSAGE=$(echo "$ROW_COMMIT_MESSAGE" | tr -d '\r')  # CRLF -> LF

# Переменные, в которых без проблем можно поменять значения на свой взгляд
ALLOWED_COMMIT_TYPES="fix:|refactor:|test:"
PREFIX_TASK_NAME="OSG"
MAX_LEN_COMMIT_MESSAGE=250
MIN_COMMIT_MESSAGE_BODY_WORDS=5
MIN_COMMIT_MESSAGE_BODY_CHARS=30
EXAMPLE_GOOD_COMMIT_MESSAGE="Пример хорошего коммита «fix: [${PREFIX_TASK_NAME}-1194] написал  метод 'calcDevSalary()', который увеличивает зарплату программистам вдвое»"


# ---------- 1. Проверка на наличие разрешенного типа коммита ----------
if ! [[ "${COMMIT_MESSAGE}" =~ ^(${ALLOWED_COMMIT_TYPES}) ]]; then
    echo "Ошибка: сообщение коммита должно начинаться с одного из следующих типов с двоеточием: ${ALLOWED_COMMIT_TYPES}"
    echo "${EXAMPLE_GOOD_COMMIT_MESSAGE}"
    exit 1
fi

# ---------- 2. Проверка на наличие задачи и описания изменений ----------
if [[ "${COMMIT_MESSAGE}" =~ ^(${ALLOWED_COMMIT_TYPES})[[:space:]]*$ ]]; then
    echo "Ошибка: помимо типа коммита, в сообщении обязательно должны присутствовать задача и описание изменений"
    echo "${EXAMPLE_GOOD_COMMIT_MESSAGE}"
    exit 1
fi

# ---------- 3. Проверка на наличие пробела и отсутствие лишних символов перед задачей ----------
if ! [[ "${COMMIT_MESSAGE}" =~ ^(${ALLOWED_COMMIT_TYPES})[[:space:]] ]]; then
    echo "Ошибка: перед задачей должен находиться один пробел и никаких лишних символов"
    echo "${EXAMPLE_GOOD_COMMIT_MESSAGE}"
    exit 1
fi

# ---------- 3.1. Проверка на наличие единственного пробела перед задачей ----------
if [[ "${COMMIT_MESSAGE}" =~ ^(${ALLOWED_COMMIT_TYPES})[[:space:]]{2,} ]]; then
    echo "Ошибка: перед задачей должен находиться только один пробел"
    echo "${EXAMPLE_GOOD_COMMIT_MESSAGE}"
    exit 1
fi

# ---------- 4. Проверка на наличие задачи после типа коммита ----------
if ! [[ "${COMMIT_MESSAGE}" =~ ^(${ALLOWED_COMMIT_TYPES})[[:space:]]\[${PREFIX_TASK_NAME}-[0-9]+\] ]]; then
    echo "Ошибка: после типа коммита ожидается задача в формате [${PREFIX_TASK_NAME}-123]"
    echo "${EXAMPLE_GOOD_COMMIT_MESSAGE}"
    exit 1
fi

#----------- 5. Проверка на наличие описания изменений ----------
if [[ "${COMMIT_MESSAGE}" =~ ^(${ALLOWED_COMMIT_TYPES})[[:space:]]\[${PREFIX_TASK_NAME}-[0-9]+\][[:space:]]*$ ]]; then
    echo "Ошибка: помимо типа коммита и задачи, в сообщении обязательно должно присутствовать описание изменений"
    echo "${EXAMPLE_GOOD_COMMIT_MESSAGE}"
    exit 1
fi

# ---------- 6. Проверка на наличие пробела и отсутствие лишних символов после задачи ----------
if ! [[ "${COMMIT_MESSAGE}" =~ ^(${ALLOWED_COMMIT_TYPES})[[:space:]]\[${PREFIX_TASK_NAME}-[0-9]+\][[:space:]] ]]; then
    echo "Ошибка: после задачи должен находится один пробел и никаких лишних символов"
    echo "${EXAMPLE_GOOD_COMMIT_MESSAGE}"
    exit 1
fi

# ---------- 6.1 Проверка на наличие единственного пробела после задачи ----------
if [[ "${COMMIT_MESSAGE}" =~ ^(${ALLOWED_COMMIT_TYPES})[[:space:]]\[${PREFIX_TASK_NAME}-[0-9]+\][[:space:]]{2,} ]]; then
    echo "Ошибка: после задачи должен находится только один пробел"
    echo "${EXAMPLE_GOOD_COMMIT_MESSAGE}"
    exit 1
fi

# ---------- получаем кол-во слов и символов в теле сообщения коммита ----------
COMMIT_MESSAGE_BODY=$(echo "${COMMIT_MESSAGE}" | sed -E "s/^(${ALLOWED_COMMIT_TYPES})[[:space:]]\[${PREFIX_TASK_NAME}-[0-9]+\][[:space:]]//")
WORD_COUNT_IN_COMMIT_MESSAGE_BODY=$(echo "${COMMIT_MESSAGE_BODY}" | wc -w)
CHAR_COUNT_IN_COMMIT_MESSAGE_BODY=$(echo -n "${COMMIT_MESSAGE_BODY}" | wc -m)

# ---------- 7. Проверка на минимальное количество слов в теле сообщения коммита ----------
if (( WORD_COUNT_IN_COMMIT_MESSAGE_BODY < MIN_COMMIT_MESSAGE_BODY_WORDS )); then
    echo "Ошибка: описание изменений должно состоять более, чем из ${MIN_COMMIT_MESSAGE_BODY_WORDS} слов"
    echo "Пример: ${EXAMPLE_GOOD_COMMIT_MESSAGE}"
    exit 1
fi

# ---------- 8. Проверка на минимальное количество символов в теле сообщения коммита ----------
if (( CHAR_COUNT_IN_COMMIT_MESSAGE_BODY < MIN_COMMIT_MESSAGE_BODY_CHARS )); then
    echo "Ошибка: описание изменений должно состоять более, чем из ${MIN_COMMIT_MESSAGE_BODY_CHARS} символов. Сейчас - ${CHAR_COUNT_IN_COMMIT_MESSAGE_BODY}"
    echo "Пример: ${EXAMPLE_GOOD_COMMIT_MESSAGE}"
    exit 1
fi

# ---------- 9. Проверка на максимальное количество символов в сообщении коммита ----------
LEN_COMMIT_MESSAGE=${#COMMIT_MESSAGE}
if (( LEN_COMMIT_MESSAGE > MAX_LEN_COMMIT_MESSAGE )); then
    echo "Ошибка: текущая длина сообщения коммита: ${LEN_COMMIT_MESSAGE}. Это превышает лимит в ${MAX_LEN_COMMIT_MESSAGE} символов"
    echo "Пожалуйста, опиши свои изменения более компактно"
    exit 1
fi

# Все проверки прошли, сообщение коммита валидное
exit 0
